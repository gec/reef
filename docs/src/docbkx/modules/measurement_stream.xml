<section id="measurement_stream">
    <title>Measurement Subsystem</title>
    <para>
        The movement of measurement data to consumer applications is the single most important responsibility of the
        Reef system.

        Without a reliable and trustworthy flow of measurements from the field a SCADA system is practically
        worthless so much of the advanced engineering in Reef is to support the measurement stream.
    </para>

    <section id="measurement_model">
        <title>Points and Measurements</title>
        <para>
            In Reef, all Measurements are associated with a Point.

            Points can be thought of as the mailbox where all past and current measurements for the real world
            value are sent and stored.

            If we want to know the current value we open the mailbox and pull out the most recent measurements.

            If we want to look at the history of a Point we open the mailbox and pull out all the measurements received
            in the appropriate time frame.
        </para>
    </section>

    <section id="measurement_model">
        <title>Consuming Measurements</title>
        <para>
            When an application wants to consume measurements it has two choices.

            Using the MeasurementSnapshotService, it can either periodically poll the service and check to see which
            measurements have changed or make setup a subscription to get an update each time a measurement is updated.

            It is recommended that all applications use subscriptions, it consumes less resources and reduces latency
            to a minimum.

        </para>
    </section>

    <section id="measurement_stream_stream">
        <title>Measurement Stream</title>
        <para>
            Measurements begin in field devices; usually they are physical sensors measuring real values.

            Reef uses field protocols to collect the measurements from the IEDs (CommunicationEndpoints).

            These field protocols are generally tailored to SCADA applications and modeled with the same
            sorts of Points and Measurements making translation straightforward.

            A Reef enabled ProtocolAdapter for the field protocol will take the raw measurements and convert them to
            a Reef Measurement protobuf object and send them to the measurement processor.

            The measurement processor inspects each measurement, applying whatever transformations or overrides are
            necessary and then stores them in the MeasurementStore and publishes the measurements to the "engineering"
            channel for consumption by applications.
        </para>
        <figure id="measurement_stream_diagram">
            <title>Measurement Stream</title>
            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="images/placeholder.png"/>
                </imageobject>
            </mediaobject>
            <remark>Show field device in cloud, protocol adapter, measurement processor, db, broker, subscriptions</remark>
        </figure>
    </section>


    <section id="measurement_stream_triggers">
        <title>Processing</title>
        <para>
            When processing a raw measurement into an "engineering measurement" each measurement goes through the
            following steps:
            <itemizedlist>
                <listitem>
                    <emphasis>Overrides:</emphasis>
                    Field data can be blocked from making it to the engineer channel.

                    Each measurement is checked against the list of blocked points and either sent on for furthur
                    processing or sent to a local cache.
                </listitem>
                <listitem>
                    <emphasis>Processing:</emphasis>
                    Raw measurements from the field often need manipulations to transform them to engineering values or
                    annotate the quality of the measurements.

                    The measurement processor is also responsible for generating Events when measurements meet certain
                    conditions.
                </listitem>
                <listitem>
                    <emphasis>Publishing:</emphasis>
                    Once the measurements are processed they are published first to the MeasurementStore then to the
                    engineering channel.
                </listitem>
            </itemizedlist>
        </para>
        <figure id="measurement_processor_steps">
            <title>Measurement Processor Steps</title>
            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="images/placeholder.png"/>
                </imageobject>
            </mediaobject>
            <remark>Adapt daniels slide with 4 vertical bars, add state cache</remark>
        </figure>
        <section id="measurement_stream_overrides">
            <title>Measurement Overrides</title>
            <para>
                Sometimes it is necessary to override the "real world" field measurements for a point.

                This is usually done for one of two reasons:
                <itemizedlist>
                    <listitem>
                        <emphasis>Bad Values:</emphasis>
                        A field device is reporting a bad value (wildly oscillating or pinned to 0) and is generating
                        spurious alarms or confusing "advanced apps" that are performing calculations on that value.

                        In this case an operator will override that data to a nominal value.
                    </listitem>
                    <listitem>
                        <emphasis>Training or Testing:</emphasis>
                        when an operator or integrator is testing alarms/UI/apps its often valuable to just
                        be able to quickly override a value and see that the correct behaviors occur.
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                There are two ways this is done, marking a point "Not in Service" (NIS) and "Overriding" the Point.

                Both methods will cause one more measurement to be published for the Point and stop all future field
                measurements from making it to the engineering channel.

                The quality of the published measurement is altered to indicate that the measurement is SUBSTITUTED and
                there will be no future updates coming.

            </para>
            <para>
                When the measurement Override or NIS is removed from a Point, the most recently received field value
                will be
                published to indicate that the measurement stream is "live" again.
            </para>
            <para>
                The difference between NIS and Overrides is the final value that is published:
                <itemizedlist>
                    <listitem>
                        <emphasis>Not in Service (NIS):</emphasis>
                        Re-publishes the last field measurement with adjusted quality.
                    </listitem>
                    <listitem>
                        <emphasis>Override:</emphasis>
                        Takes an operator supplied measurement to set a specific value.
                    </listitem>
                </itemizedlist>
                <caution>
                    <para>It is important to use NIS if not trying to set the point to a specific value.

                        If a client application attempts to read the current value, update quality and set it as an
                        override, measurements can be lost "in-flight".

                        The measurement processor is the only place in the system that can guarantee no lost
                        measurements.
                    </para>
                </caution>
            </para>
        </section>
        <section id="measurement_transformations">
            <title>Measurement Transformations</title>
            <para>
                Converting a raw measurement to its engineering representation and generating events can be very use
                case specific and a one-size-fits-all solution is not flexible to production data streams.

                For example some installations may want to pre-check all incoming data to verify that the value is
                "reasonable" and generate a different sort of event for that case.

                To stay flexible each Point has its processing steps explicitly configured when the system is loaded.

                Each measurement may have many steps and each step is defined in terms of a "Trigger Condition" and an
                "Action" to perform if the conditions match.
            </para>
            <section>
                <title>Trigger Conditions</title>
                <para>
                    To determine whether performing an action is necessary each processing step specifies the conditions
                    the measurement must meet.

                    A step will not be executed unless all conditions match (logical AND).

                    Common triggers are:
                    <itemizedlist>
                        <listitem>
                            <emphasis>Unit:</emphasis>
                            Checks that the measurement has correct unit.

                            Measurements from Reef ProtocolAdapters will attach the unit "raw" to all measurements
                            with a unit specified.

                            Most transformation steps will require that the unit matches "raw" to apply the
                            transformation.

                            If the only condition is unit, make sure that action updates the unit.

                            Nearly every step should indicate the expected unit.
                        </listitem>
                        <listitem>
                            <emphasis>Exact Value:</emphasis>
                            Some steps (usually Event generation) only activate if a Measurement has a specific value.

                            We can check for exact boolean, string and integer values.
                        </listitem>
                        <listitem>
                            <emphasis>Ranges:</emphasis>
                            A common pattern is to check that a Measurement is inside of a certain range of values.

                            Multiple overlapping ranges are often specified for a single point to provide different
                            events when a measurement exceeds the nominal range into the warning range and when it
                            strays into a dangerous range.

                            Ranges can also have a deadband to stop a value oscillating near a range boundary from
                            generating too many events.
                        </listitem>
                    </itemizedlist>
                </para>
                <figure id="measurement_processor_steps">
                    <title>Multiple Ranges</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata align="center" fileref="images/placeholder.png"/>
                        </imageobject>
                    </mediaobject>
                    <remark>Show multiple ranges: nominal, warning, dangerous. RLC?</remark>
                </figure>
                <para>
                    When we determine that a measurement matches all of the trigger conditions we say the "trigger is
                    active" and start processing actions.

                    Many actions will be run whenever the trigger is active, but in some cases it is valuable to
                    run an action when a trigger is first activated or when it is de-activated.

                    This is sometimes reffered to as "edge-triggering" and "level-triggering", both are supported.

                    Actions therefore have a ActivationType that indicates when the action can be performed.
                    <itemizedlist>
                        <listitem>
                            <emphasis>HIGH:</emphasis>
                            Do action whenever trigger is active, most transformations and annotations use HIGH.
                        </listitem>
                        <listitem>
                            <emphasis>LOW:</emphasis>
                            Do action whenever trigger is in-active, not commonly used.
                        </listitem>
                        <listitem>
                            <emphasis>RISING:</emphasis>
                            Do action when trigger is first activated, often used to generate "Measurement
                            went out of Nominal" events.
                        </listitem>
                        <listitem>
                            <emphasis>FALLING:</emphasis>
                            Do action when trigger was active and is now in-active, can be used to generate
                            "Measurement returned to Nominal" events.
                        </listitem>
                        <listitem>
                            <emphasis>TRANSITION:</emphasis>
                            Do action when trigger active state changes, often used to generate
                            "Measurement nominal status changed" events.
                        </listitem>
                    </itemizedlist>
                </para>
                <figure id="action_activations">
                    <title>Action Triggering Conditions</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata align="center" fileref="images/placeholder.png"/>
                        </imageobject>
                    </mediaobject>
                    <remark>Show on/off edge triggering.</remark>
                </figure>
            </section>
            <section>
                <title>Processing Actions</title>
                <para>
                    The measurement processor is capable of performing the following actions on each measurement:
                    <itemizedlist>
                        <listitem>
                            <emphasis>Scale:</emphasis>
                            It is common that data from the field is sent with the wrong scale or unit.

                            For example many legacy protocols do not have support for "floating point" values so devices
                            are configured to send 100 or 1000 times the value.

                            Reef provides a linear transformation with slope and offset.
                        </listitem>
                        <listitem>
                            <emphasis>Enum Transformation:</emphasis>
                            Many measurements (in particular statuses) need to be converted to Enums for use in
                            applications.

                            A boolean value of true may indicate "CLOSED" for a breaker but indicate "NOMINAL" for a
                            door alarm point.

                            The measurement processor will do this transformation so applications and operators don't
                            need remember the mappings between boolean values and real world state.

                            The measurement type is changed to string but the underlying boolean value is still
                            available if needed.

                            Less common but also supported is turning integer values into enums.
                        </listitem>
                        <listitem>
                            <emphasis>Quality Annotation:</emphasis>
                            We often want to update the quality of a measurement but not affect the value.

                            The most common case is to set the quality bit "abnormal" when the measurement is outside
                            expected or nominal values.
                        </listitem>
                        <listitem>
                            <emphasis>Generate Event:</emphasis>
                            When a measurement matches some condition (usually an undesired value) we want to alert
                            the operator quickly by generating an Event.

                            The action configuration determines what event code we are going to publish.

                            The Point name, current value and quality are all sent as attributes to event service to create
                            helpful event messages.
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
        </section>
    </section>
    <section id="measurement_publishing">
        <title>Measurement Publishing</title>
        <para>
            Once a measurement is full processed it is published to two places.

            First it is published to the MeasurementStore, which is responsible for storing the current and historical
            values for each Point.

            Once written to the store the measurements are published to the "engineering channel" and the message
            broker sends a copy to every application that has subscribed to those measurements.
        </para>
    </section>

</section>